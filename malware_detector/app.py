import datetime
import hashlib
import os
import shutil

import yara  # Import YARA
from flask import Flask, flash, jsonify, redirect, render_template, request, url_for

app = Flask(__name__)
app.secret_key = "a_more_secure_secret_key_please_change"  # CHANGE THIS!

# --- Configuration ---
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
SCAN_DIRECTORY = os.path.join(BASE_DIR, "scan_target")
QUARANTINE_DIRECTORY = os.path.join(BASE_DIR, "quarantine")
YARA_RULES_FILE = os.path.join(BASE_DIR, "rules.yar")  # Path to your YARA rules

# !!! IMPORTANT: Replace with ACTUAL MD5 hashes of your dummy 'bad' files !!!
KNOWN_MALWARE_HASHES = {
    "ffba6e443904afcd08fb14577f949327",  # Example: bad_file_1.txt
    "1eb9a1a602dee0b8277d099f3abca474",  # Example: bad_file_2.exe
    # Add hashes for other test files you create
}

SUSPICIOUS_EXTENSIONS = {
    ".exe",
    ".dll",
    ".bat",
    ".cmd",
    ".vbs",
    ".js",
    ".ps1",
    ".scr",
    ".msi",
    # Add more potentially suspicious extensions
}

DOUBLE_EXTENSIONS_TRIGGER = {".exe", ".bat", ".vbs", ".scr"}  # e.g. file.txt.exe

# Load YARA rules once at startup
try:
    yara_rules = yara.compile(filepath=YARA_RULES_FILE)
    print(f"Successfully compiled YARA rules from {YARA_RULES_FILE}")
except yara.Error as e:
    print(f"FATAL: Could not compile YARA rules from {YARA_RULES_FILE}: {e}")
    print("YARA detection will be disabled.")
    yara_rules = None  # Disable YARA if rules can't load
except FileNotFoundError:
    print(
        f"WARNING: YARA rules file not found at {YARA_RULES_FILE}. YARA detection disabled."
    )
    yara_rules = None
# --- End Configuration ---


def get_md5(filepath):
    """Calculates the MD5 hash of a file."""
    hash_md5 = hashlib.md5()
    try:
        with open(filepath, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    except Exception:
        return None


def check_suspicious_extension(filename):
    """Checks for suspicious single or double extensions."""
    parts = filename.lower().split(".")
    if len(parts) > 1:
        ext = f".{parts[-1]}"
        if ext in SUSPICIOUS_EXTENSIONS:
            return True, f"Suspicious Extension ({ext})"

        # Check for double extensions like .txt.exe
        if len(parts) > 2:
            double_ext_check = f".{parts[-1]}"
            if double_ext_check in DOUBLE_EXTENSIONS_TRIGGER:
                # Check if the preceding part looks like a common document/image extension
                potential_hidden_ext = f".{parts[-2]}"
                common_decoys = {
                    ".txt",
                    ".pdf",
                    ".doc",
                    ".docx",
                    ".xls",
                    ".xlsx",
                    ".ppt",
                    ".pptx",
                    ".jpg",
                    ".jpeg",
                    ".png",
                    ".gif",
                }
                if potential_hidden_ext in common_decoys:
                    return (
                        True,
                        f"Potential Double Extension ({potential_hidden_ext}{double_ext_check})",
                    )
    return False, ""


# --- Feature 1: Enhanced Detection ---
def scan_directory(directory):
    """Scans a directory using multiple detection methods."""
    detected_threats = (
        []
    )  # Store dictionaries: {'path': str, 'reason': str, 'details': str}
    scanned_files_count = 0
    errors = []

    if not os.path.isdir(directory):
        errors.append(f"Scan directory '{directory}' not found.")
        return [], 0, errors

    for root, _, files in os.walk(directory):
        for filename in files:
            filepath = os.path.join(root, filename)
            scanned_files_count += 1
            detected = False  # Flag to prevent multiple detections per file

            # 1. YARA Rule Matching (Highest Priority)
            if yara_rules and not detected:
                try:
                    matches = yara_rules.match(filepath)
                    if matches:
                        # Join names of all matching rules
                        rule_names = ", ".join([match.rule for match in matches])
                        detected_threats.append(
                            {
                                "path": filepath,
                                "reason": "YARA Rule",
                                "details": rule_names,
                            }
                        )
                        detected = True
                except Exception as e:  # Catch errors during YARA matching
                    errors.append(f"YARA Error scanning {filename}: {e}")

            # 2. Hash Matching (Medium Priority)
            if not detected:
                file_hash = get_md5(filepath)
                if file_hash and file_hash in KNOWN_MALWARE_HASHES:
                    detected_threats.append(
                        {
                            "path": filepath,
                            "reason": "Known Hash",
                            "details": file_hash[:12] + "...",  # Show partial hash
                        }
                    )
                    detected = True

            # 3. Suspicious Extension (Lower Priority)
            if not detected:
                is_suspicious, reason_detail = check_suspicious_extension(filename)
                if is_suspicious:
                    detected_threats.append(
                        {
                            "path": filepath,
                            "reason": "Suspicious Name",
                            "details": reason_detail,
                        }
                    )
                    detected = True

    return detected_threats, scanned_files_count, errors


# --- Feature 2: Quarantine (Mostly unchanged logic, updated messaging) ---
def quarantine_files(file_paths):
    quarantined_details = []  # Store {'original_path': str, 'quarantine_path': str}
    errors = []
    success_count = 0

    if not file_paths:
        return [], errors, success_count

    if not os.path.exists(QUARANTINE_DIRECTORY):
        try:
            os.makedirs(QUARANTINE_DIRECTORY)
        except OSError as e:
            errors.append(
                f"Fatal: Could not create quarantine directory '{QUARANTINE_DIRECTORY}': {e}"
            )
            return [], errors, success_count  # Cannot proceed

    for file_path in file_paths:
        if not isinstance(file_path, str) or not file_path:  # Basic validation
            errors.append("Invalid file path received for quarantine.")
            continue

        if not os.path.exists(file_path):
            errors.append(
                f"File not found for quarantine (already moved/deleted?): {os.path.basename(file_path)}"
            )
            continue
        try:
            filename = os.path.basename(file_path)
            # Add simple counter to prevent overwrite name clashes in quarantine
            base, ext = os.path.splitext(filename)
            counter = 0
            destination = os.path.join(QUARANTINE_DIRECTORY, filename)
            while os.path.exists(destination):
                counter += 1
                destination = os.path.join(
                    QUARANTINE_DIRECTORY, f"{base}_{counter}{ext}"
                )

            shutil.move(file_path, destination)
            quarantined_details.append(
                {"original_path": file_path, "quarantine_path": destination}
            )
            success_count += 1
        except Exception as e:
            errors.append(f"Error quarantining {os.path.basename(file_path)}: {e}")

    return quarantined_details, errors, success_count


# --- Feature 3: Removal (Mostly unchanged logic, updated messaging) ---
def remove_files(file_paths):
    removed_paths = []
    errors = []
    success_count = 0

    if not file_paths:
        return [], errors, success_count

    quarantine_abs_path = os.path.abspath(QUARANTINE_DIRECTORY)

    for file_path in file_paths:
        if not isinstance(file_path, str) or not file_path:  # Basic validation
            errors.append("Invalid file path received for removal.")
            continue

        file_abs_path = os.path.abspath(file_path)

        # SECURITY CHECK: Ensure we are only deleting from within the quarantine directory
        if not file_abs_path.startswith(quarantine_abs_path):
            errors.append(
                f"Security Alert: Attempted removal outside quarantine denied for: {os.path.basename(file_path)}"
            )
            continue

        if not os.path.exists(file_path):
            errors.append(
                f"File not found for removal (already removed?): {os.path.basename(file_path)}"
            )
            continue
        try:
            os.remove(file_path)
            removed_paths.append(file_path)  # Store the path that was removed
            success_count += 1
        except Exception as e:
            errors.append(
                f"Error removing {os.path.basename(file_path)} from quarantine: {e}"
            )
    return removed_paths, errors, success_count


# --- Flask Routes ---
@app.route("/")
def index():
    """Display the main page."""
    current_year = datetime.datetime.now().year  # <-- GET CURRENT YEAR
    if not os.path.isdir(SCAN_DIRECTORY):
        flash(
            f"Warning: Scan directory '{SCAN_DIRECTORY}' not found. Please create it.",
            "warning",
        )
    # Pass the year to the template
    return render_template(
        "index.html", scan_dir=SCAN_DIRECTORY, current_year=current_year
    )


@app.route("/scan", methods=["POST"])
def perform_scan():
    """Handle the scan request."""
    current_year = datetime.datetime.now().year  # <-- GET CURRENT YEAR
    flash(f"Starting scan of '{SCAN_DIRECTORY}'...", "info")
    detected_threats, scanned_count, scan_errors = scan_directory(SCAN_DIRECTORY)

    for error in scan_errors:
        flash(error, "danger")

    flash(f"Scan complete. Scanned {scanned_count} files.", "secondary")

    if not detected_threats:
        flash("No threats detected based on current rules and signatures.", "success")
    else:
        flash(f"Detected {len(detected_threats)} potential threats.", "warning")

    # Pass the year to the template
    return render_template(
        "results.html", detected_threats=detected_threats, current_year=current_year
    )


@app.route("/quarantine", methods=["POST"])
def perform_quarantine():
    """Handle the quarantine request."""
    current_year = datetime.datetime.now().year  # <-- GET CURRENT YEAR
    files_to_quarantine = request.form.getlist("file_to_action")

    if not files_to_quarantine:
        flash("No files selected for quarantine.", "warning")
        return redirect(url_for("index"))

    flash(
        f"Attempting to quarantine {len(files_to_quarantine)} selected file(s)...",
        "info",
    )
    quarantined_details, errors, success_count = quarantine_files(files_to_quarantine)

    for error in errors:
        flash(error, "danger")

    if success_count > 0:
        flash(f"Successfully quarantined {success_count} file(s).", "success")

    # Pass the year to the template
    return render_template(
        "final.html",
        action_taken="Quarantine",
        action_details=quarantined_details,
        allow_removal=bool(quarantined_details),
        current_year=current_year,
    )  # <-- PASS YEAR


@app.route("/remove", methods=["POST"])
def perform_removal():
    """Handle the removal request."""
    current_year = datetime.datetime.now().year  # <-- GET CURRENT YEAR
    files_to_remove = request.form.getlist("file_to_action")

    if not files_to_remove:
        flash("No files selected for removal.", "warning")
        return redirect(url_for("index"))

    flash(
        f"Attempting to remove {len(files_to_remove)} selected quarantined file(s)...",
        "info",
    )
    removed_paths, errors, success_count = remove_files(files_to_remove)

    for error in errors:
        flash(error, "danger")

    if success_count > 0:
        flash(
            f"Successfully removed {success_count} file(s) from quarantine.", "success"
        )

    # Pass the year to the template
    return render_template(
        "final.html",
        action_taken="Removal",
        action_details=[{"quarantine_path": p} for p in removed_paths],
        allow_removal=False,
        current_year=current_year,
    )  # <-- PASS YEAR


# ... (keep existing main execution block) ...

if __name__ == "__main__":
    if not os.path.exists(SCAN_DIRECTORY):
        print(
            f"Warning: Scan directory '{SCAN_DIRECTORY}' does not exist. Please create it and add test files."
        )
    # Ensure YARA rule loading feedback happens on start
    if yara_rules is None:
        print(
            "Reminder: YARA detection is currently disabled due to missing or invalid rules file."
        )

    app.run(debug=True)  # debug=True reloads on code changes
