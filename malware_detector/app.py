import configparser
import datetime
import hashlib
import logging  # Import logging
import os
import shutil

import yara
from flask import Flask, flash, jsonify, redirect, render_template, request, url_for

# --- Basic Logging Setup ---
log_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)
# Default log level (can be overridden by config)
logger.setLevel(logging.INFO)

# Console Handler (optional, for seeing logs during development)
# console_handler = logging.StreamHandler()
# console_handler.setFormatter(log_formatter)
# logger.addHandler(console_handler)

# --- Configuration Loading ---
config = configparser.ConfigParser()
BASE_DIR = os.path.abspath(os.path.dirname(__file__))
CONFIG_FILE = os.path.join(BASE_DIR, "config.ini")

# Default values
DEFAULT_CONFIG = {
    "Paths": {
        "ScanDirectory": "scan_target",
        "QuarantineDirectory": "quarantine",
        "YaraRulesFile": "rules.yar",
        "LogFile": "malware_detector.log",
    },
    "Detection": {
        "SuspiciousExtensions": ".exe,.dll,.bat,.cmd,.vbs,.js,.ps1,.scr,.msi",
        "DoubleExtensionTriggers": ".exe,.bat,.vbs,.scr",
    },
    "Signatures": {"KnownMD5Hashes": "", "KnownSHA256Hashes": ""},
    "Logging": {"LogLevel": "INFO"},
}

try:
    if not os.path.exists(CONFIG_FILE):
        print(
            f"Warning: Configuration file '{CONFIG_FILE}' not found. Using default settings."
        )
        # Optionally create a default config file here if desired
        # config.read_dict(DEFAULT_CONFIG) # Start with defaults if file missing
    else:
        config.read(CONFIG_FILE)
        print(f"Loaded configuration from {CONFIG_FILE}")

    # Apply defaults for missing sections/options
    for section, options in DEFAULT_CONFIG.items():
        if not config.has_section(section):
            config.add_section(section)
        for option, value in options.items():
            if not config.has_option(section, option):
                config.set(section, option, value)

except configparser.Error as e:
    print(
        f"Error reading configuration file '{CONFIG_FILE}': {e}. Using default settings."
    )
    config.read_dict(DEFAULT_CONFIG)  # Fallback to defaults on error


# Read settings from config
try:
    SCAN_DIRECTORY_NAME = config.get(
        "Paths", "ScanDirectory", fallback=DEFAULT_CONFIG["Paths"]["ScanDirectory"]
    )
    QUARANTINE_DIRECTORY_NAME = config.get(
        "Paths",
        "QuarantineDirectory",
        fallback=DEFAULT_CONFIG["Paths"]["QuarantineDirectory"],
    )
    YARA_RULES_FILE_NAME = config.get(
        "Paths", "YaraRulesFile", fallback=DEFAULT_CONFIG["Paths"]["YaraRulesFile"]
    )
    LOG_FILE_NAME = config.get(
        "Paths", "LogFile", fallback=DEFAULT_CONFIG["Paths"]["LogFile"]
    )
    LOG_LEVEL_STR = config.get(
        "Logging", "LogLevel", fallback=DEFAULT_CONFIG["Logging"]["LogLevel"]
    ).upper()

    # Construct full paths
    SCAN_DIRECTORY = os.path.join(BASE_DIR, SCAN_DIRECTORY_NAME)
    QUARANTINE_DIRECTORY = os.path.join(BASE_DIR, QUARANTINE_DIRECTORY_NAME)
    YARA_RULES_FILE = os.path.join(BASE_DIR, YARA_RULES_FILE_NAME)
    LOG_FILE = os.path.join(BASE_DIR, LOG_FILE_NAME)

    # Parse comma-separated lists into sets, removing empty strings
    def parse_comma_list(list_string):
        return {item.strip().lower() for item in list_string.split(",") if item.strip()}

    SUSPICIOUS_EXTENSIONS = parse_comma_list(
        config.get(
            "Detection",
            "SuspiciousExtensions",
            fallback=DEFAULT_CONFIG["Detection"]["SuspiciousExtensions"],
        )
    )
    DOUBLE_EXTENSIONS_TRIGGER = parse_comma_list(
        config.get(
            "Detection",
            "DoubleExtensionTriggers",
            fallback=DEFAULT_CONFIG["Detection"]["DoubleExtensionTriggers"],
        )
    )

    KNOWN_HASHES = {
        "md5": parse_comma_list(
            config.get(
                "Signatures",
                "KnownMD5Hashes",
                fallback=DEFAULT_CONFIG["Signatures"]["KnownMD5Hashes"],
            )
        ),
        "sha256": parse_comma_list(
            config.get(
                "Signatures",
                "KnownSHA256Hashes",
                fallback=DEFAULT_CONFIG["Signatures"]["KnownSHA256Hashes"],
            )
        ),
    }

    # --- Setup File Logging Handler ---
    log_level = getattr(logging, LOG_LEVEL_STR, logging.INFO)
    logger.setLevel(log_level)
    try:
        file_handler = logging.FileHandler(LOG_FILE)
        file_handler.setFormatter(log_formatter)
        logger.addHandler(file_handler)
        logger.info(
            f"Logging initialized. Level: {LOG_LEVEL_STR}. Log file: {LOG_FILE}"
        )
    except Exception as e:
        print(f"Error setting up file logger for {LOG_FILE}: {e}")
        logger.error(f"Failed to setup file logging for {LOG_FILE}", exc_info=True)


except Exception as e:
    # Broad exception catch during config loading
    print(
        f"CRITICAL ERROR during configuration processing: {e}. Application might not function correctly."
    )
    logger.critical(f"Configuration processing failed: {e}", exc_info=True)
    # Set fallback defaults manually if config object might be broken
    SCAN_DIRECTORY = os.path.join(BASE_DIR, DEFAULT_CONFIG["Paths"]["ScanDirectory"])
    QUARANTINE_DIRECTORY = os.path.join(
        BASE_DIR, DEFAULT_CONFIG["Paths"]["QuarantineDirectory"]
    )
    YARA_RULES_FILE = os.path.join(BASE_DIR, DEFAULT_CONFIG["Paths"]["YaraRulesFile"])
    SUSPICIOUS_EXTENSIONS = parse_comma_list(
        DEFAULT_CONFIG["Detection"]["SuspiciousExtensions"]
    )
    DOUBLE_EXTENSIONS_TRIGGER = parse_comma_list(
        DEFAULT_CONFIG["Detection"]["DoubleExtensionTriggers"]
    )
    KNOWN_HASHES = {
        "md5": parse_comma_list(DEFAULT_CONFIG["Signatures"]["KnownMD5Hashes"]),
        "sha256": parse_comma_list(DEFAULT_CONFIG["Signatures"]["KnownSHA256Hashes"]),
    }


# --- Initialize Flask App ---
app = Flask(__name__)
# Consider using environment variable or separate secrets file for production
app.secret_key = os.environ.get(
    "FLASK_SECRET_KEY", "a_more_secure_secret_key_please_change"
)  # CHANGE THIS default


# --- Load YARA rules ---
try:
    if not os.path.exists(YARA_RULES_FILE):
        logger.warning(
            f"YARA rules file not found at {YARA_RULES_FILE}. YARA detection disabled."
        )
        yara_rules = None
    else:
        yara_rules = yara.compile(filepath=YARA_RULES_FILE)
        logger.info(f"Successfully compiled YARA rules from {YARA_RULES_FILE}")
except yara.Error as e:
    logger.error(
        f"Could not compile YARA rules from {YARA_RULES_FILE}: {e}", exc_info=True
    )
    logger.warning("YARA detection will be disabled.")
    yara_rules = None  # Disable YARA if rules can't load
# --- End Configuration and Setup ---


def get_file_hashes(filepath):
    """Calculates MD5 and SHA256 hash of a file."""
    # BUFFER_SIZE = 65536 # 64kb chunks
    md5_hash = hashlib.md5()
    sha256_hash = hashlib.sha256()
    try:
        with open(filepath, "rb") as f:
            while True:
                data = f.read(4096)  # Read in chunks
                if not data:
                    break
                md5_hash.update(data)
                sha256_hash.update(data)
        return {"md5": md5_hash.hexdigest(), "sha256": sha256_hash.hexdigest()}
    except Exception as e:
        logger.error(f"Error hashing file {filepath}: {e}", exc_info=True)
        return None


def check_suspicious_extension(filename):
    """Checks for suspicious single or double extensions."""
    # Logic remains the same, uses config-loaded sets
    parts = filename.lower().split(".")
    if len(parts) > 1:
        ext = f".{parts[-1]}"
        if ext in SUSPICIOUS_EXTENSIONS:
            return True, f"Suspicious Extension ({ext})"

        if len(parts) > 2:
            double_ext_check = f".{parts[-1]}"
            if double_ext_check in DOUBLE_EXTENSIONS_TRIGGER:
                potential_hidden_ext = f".{parts[-2]}"
                common_decoys = {
                    ".txt",
                    ".pdf",
                    ".doc",
                    ".docx",
                    ".xls",
                    ".xlsx",
                    ".ppt",
                    ".pptx",
                    ".jpg",
                    ".jpeg",
                    ".png",
                    ".gif",
                }
                if potential_hidden_ext in common_decoys:
                    return (
                        True,
                        f"Potential Double Extension ({potential_hidden_ext}{double_ext_check})",
                    )
    return False, ""


# --- Feature 1: Enhanced Detection ---
def scan_directory(directory):
    """Scans a directory using multiple detection methods."""
    detected_threats = []
    scanned_files_count = 0
    errors = []
    logger.info(f"Starting scan in directory: {directory}")

    if not os.path.isdir(directory):
        errmsg = f"Scan directory '{directory}' not found or is not a directory."
        errors.append(errmsg)
        logger.error(errmsg)
        return [], 0, errors

    # Use scandir for potentially better performance
    try:
        for entry in os.scandir(directory):
            if entry.is_file():
                filepath = entry.path
                filename = entry.name
                scanned_files_count += 1
                detected = False
                detection_info = {}  # Store details for logging

                logger.debug(f"Scanning file: {filepath}")

                # 1. YARA Rule Matching
                if yara_rules and not detected:
                    try:
                        matches = yara_rules.match(filepath)
                        if matches:
                            rule_names = ", ".join([match.rule for match in matches])
                            detection_info = {
                                "path": filepath,
                                "reason": "YARA Rule",
                                "details": rule_names,
                            }
                            detected_threats.append(detection_info)
                            detected = True
                            logger.warning(
                                f"YARA Match: {rule_names} in file {filepath}"
                            )
                    except Exception as e:
                        errmsg = f"YARA error scanning {filename}: {e}"
                        errors.append(errmsg)
                        logger.error(errmsg, exc_info=True)

                # 2. Hash Matching (MD5 and SHA256)
                if not detected:
                    file_hashes = get_file_hashes(filepath)
                    if file_hashes:
                        md5 = file_hashes["md5"]
                        sha256 = file_hashes["sha256"]

                        # Check MD5
                        if md5 in KNOWN_HASHES.get("md5", set()):
                            detection_info = {
                                "path": filepath,
                                "reason": "Known Hash (MD5)",
                                "details": md5[:12] + "...",
                            }
                            detected_threats.append(detection_info)
                            detected = True
                            logger.warning(f"MD5 Match: {md5} in file {filepath}")
                        # Check SHA256 (only if MD5 didn't match)
                        elif sha256 in KNOWN_HASHES.get("sha256", set()):
                            detection_info = {
                                "path": filepath,
                                "reason": "Known Hash (SHA256)",
                                "details": sha256[:12] + "...",
                            }
                            detected_threats.append(detection_info)
                            detected = True
                            logger.warning(f"SHA256 Match: {sha256} in file {filepath}")
                    else:
                        logger.debug(f"Could not get hashes for file {filepath}")

                # 3. Suspicious Extension
                if not detected:
                    is_suspicious, reason_detail = check_suspicious_extension(filename)
                    if is_suspicious:
                        detection_info = {
                            "path": filepath,
                            "reason": "Suspicious Name",
                            "details": reason_detail,
                        }
                        detected_threats.append(detection_info)
                        detected = True
                        logger.info(
                            f"Suspicious Name Match: {reason_detail} for file {filepath}"
                        )  # Log as info, might be less severe

            elif entry.is_dir():
                # Simple recursive call - could be improved for depth limiting etc.
                # Note: This simple recursion might re-log start/end messages multiple times
                logger.debug(f"Entering subdirectory: {entry.path}")
                sub_threats, sub_scanned, sub_errors = scan_directory(entry.path)
                detected_threats.extend(sub_threats)
                scanned_files_count += sub_scanned
                errors.extend(sub_errors)

    except OSError as e:
        errmsg = f"OS Error scanning directory {directory}: {e}"
        errors.append(errmsg)
        logger.error(errmsg, exc_info=True)
    except Exception as e:
        errmsg = f"Unexpected error scanning directory {directory}: {e}"
        errors.append(errmsg)
        logger.error(errmsg, exc_info=True)

    logger.info(
        f"Scan finished for directory: {directory}. Files scanned: {scanned_files_count}. Threats found: {len(detected_threats)}. Errors: {len(errors)}."
    )
    return detected_threats, scanned_files_count, errors


# --- Feature 2: Quarantine ---
def quarantine_files(file_paths):
    quarantined_details = []
    errors = []
    success_count = 0
    logger.info(
        f"Attempting to quarantine {len(file_paths)} file(s). Target dir: {QUARANTINE_DIRECTORY}"
    )

    if not file_paths:
        logger.warning("Quarantine called with empty file list.")
        return [], errors, success_count

    if not os.path.exists(QUARANTINE_DIRECTORY):
        try:
            os.makedirs(QUARANTINE_DIRECTORY)
            logger.info(f"Created quarantine directory: {QUARANTINE_DIRECTORY}")
        except OSError as e:
            errmsg = f"Fatal: Could not create quarantine directory '{QUARANTINE_DIRECTORY}': {e}"
            errors.append(errmsg)
            logger.critical(errmsg, exc_info=True)
            return [], errors, success_count

    for file_path in file_paths:
        if not isinstance(file_path, str) or not file_path:
            errmsg = (
                f"Invalid file path type received for quarantine: {type(file_path)}"
            )
            errors.append(errmsg)
            logger.error(errmsg)
            continue

        filename = os.path.basename(file_path)  # Get filename early for logging

        if not os.path.exists(file_path):
            errmsg = f"File not found for quarantine: {filename} (Path: {file_path})"
            errors.append(errmsg)
            logger.warning(errmsg)
            continue
        try:
            base, ext = os.path.splitext(filename)
            counter = 0
            destination = os.path.join(QUARANTINE_DIRECTORY, filename)
            while os.path.exists(destination):
                counter += 1
                destination = os.path.join(
                    QUARANTINE_DIRECTORY, f"{base}_{counter}{ext}"
                )
                logger.debug(
                    f"Quarantine name conflict for {filename}, trying {os.path.basename(destination)}"
                )

            shutil.move(file_path, destination)
            quarantined_details.append(
                {"original_path": file_path, "quarantine_path": destination}
            )
            success_count += 1
            logger.info(
                f"Successfully quarantined '{filename}' from '{file_path}' to '{destination}'"
            )
        except Exception as e:
            errmsg = f"Error quarantining {filename}: {e}"
            errors.append(errmsg)
            logger.error(errmsg, exc_info=True)

    logger.info(
        f"Quarantine process finished. Success: {success_count}, Errors: {len(errors)}."
    )
    return quarantined_details, errors, success_count


# --- Feature 3: Removal ---
def remove_files(file_paths):
    removed_paths = []
    errors = []
    success_count = 0
    logger.info(
        f"Attempting to remove {len(file_paths)} file(s) from quarantine: {QUARANTINE_DIRECTORY}"
    )

    if not file_paths:
        logger.warning("Remove called with empty file list.")
        return [], errors, success_count

    quarantine_abs_path = os.path.abspath(QUARANTINE_DIRECTORY)

    for file_path in file_paths:
        if not isinstance(file_path, str) or not file_path:
            errmsg = f"Invalid file path type received for removal: {type(file_path)}"
            errors.append(errmsg)
            logger.error(errmsg)
            continue

        filename = os.path.basename(file_path)  # For logging
        file_abs_path = os.path.abspath(file_path)

        if not file_abs_path.startswith(quarantine_abs_path):
            errmsg = f"Security Alert: Attempted removal outside quarantine denied for: {filename} (Path: {file_path})"
            errors.append(errmsg)
            logger.critical(errmsg)  # Log as critical security event
            continue

        if not os.path.exists(file_path):
            errmsg = f"File not found for removal: {filename} (Path: {file_path})"
            errors.append(errmsg)
            logger.warning(errmsg)
            continue
        try:
            os.remove(file_path)
            removed_paths.append(file_path)
            success_count += 1
            logger.info(
                f"Successfully removed quarantined file: {filename} (Path: {file_path})"
            )
        except Exception as e:
            errmsg = f"Error removing {filename} from quarantine: {e}"
            errors.append(errmsg)
            logger.error(errmsg, exc_info=True)

    logger.info(
        f"Removal process finished. Success: {success_count}, Errors: {len(errors)}."
    )
    return removed_paths, errors, success_count


# --- Flask Routes ---
@app.route("/")
def index():
    """Display the main page."""
    current_year = datetime.datetime.now().year
    logger.debug(f"Serving index page. Scan dir: {SCAN_DIRECTORY}")
    if not os.path.isdir(SCAN_DIRECTORY):
        flash(
            f"Warning: Scan directory '{SCAN_DIRECTORY_NAME}' not found. Please create it relative to the application.",
            "warning",
        )
        logger.warning(f"Scan directory does not exist: {SCAN_DIRECTORY}")
    return render_template(
        "index.html", scan_dir=SCAN_DIRECTORY_NAME, current_year=current_year
    )


@app.route("/scan", methods=["POST"])
def perform_scan():
    """Handle the scan request."""
    current_year = datetime.datetime.now().year
    logger.info("Scan request received.")
    flash(f"Starting scan of '{SCAN_DIRECTORY_NAME}'...", "info")
    detected_threats, scanned_count, scan_errors = scan_directory(SCAN_DIRECTORY)

    for error in scan_errors:
        flash(error, "danger")

    flash(f"Scan complete. Scanned {scanned_count} files.", "secondary")

    if not detected_threats:
        flash("No threats detected based on current rules and signatures.", "success")
        logger.info("Scan completed, no threats detected.")
    else:
        flash(f"Detected {len(detected_threats)} potential threats.", "warning")
        logger.warning(f"Scan completed, {len(detected_threats)} threats detected.")

    return render_template(
        "results.html", detected_threats=detected_threats, current_year=current_year
    )


@app.route("/quarantine", methods=["POST"])
def perform_quarantine():
    """Handle the quarantine request."""
    current_year = datetime.datetime.now().year
    files_to_quarantine = request.form.getlist("file_to_action")
    logger.info(f"Quarantine request received for {len(files_to_quarantine)} file(s).")

    if not files_to_quarantine:
        flash("No files selected for quarantine.", "warning")
        logger.warning("Quarantine request received but no files were selected.")
        return redirect(url_for("index"))

    flash(
        f"Attempting to quarantine {len(files_to_quarantine)} selected file(s)...",
        "info",
    )
    quarantined_details, errors, success_count = quarantine_files(files_to_quarantine)

    for error in errors:
        flash(error, "danger")  # Logged within function

    if success_count > 0:
        flash(
            f"Successfully quarantined {success_count} file(s).", "success"
        )  # Logged within function

    return render_template(
        "final.html",
        action_taken="Quarantine",
        action_details=quarantined_details,
        allow_removal=bool(quarantined_details),
        current_year=current_year,
    )


@app.route("/remove", methods=["POST"])
def perform_removal():
    """Handle the removal request."""
    current_year = datetime.datetime.now().year
    files_to_remove = request.form.getlist("file_to_action")
    logger.info(f"Removal request received for {len(files_to_remove)} file(s).")

    if not files_to_remove:
        flash("No files selected for removal.", "warning")
        logger.warning("Removal request received but no files were selected.")
        return redirect(url_for("index"))

    flash(
        f"Attempting to remove {len(files_to_remove)} selected quarantined file(s)...",
        "info",
    )
    removed_paths, errors, success_count = remove_files(files_to_remove)

    for error in errors:
        flash(error, "danger")  # Logged within function

    if success_count > 0:
        flash(
            f"Successfully removed {success_count} file(s) from quarantine.", "success"
        )  # Logged within function

    return render_template(
        "final.html",
        action_taken="Removal",
        action_details=[{"quarantine_path": p} for p in removed_paths],
        allow_removal=False,
        current_year=current_year,
    )


# --- Main Execution ---
if __name__ == "__main__":
    logger.info("Application starting...")
    if not os.path.exists(SCAN_DIRECTORY):
        logger.warning(
            f"Scan directory '{SCAN_DIRECTORY}' does not exist at startup. Please create it."
        )
    if yara_rules is None:
        logger.warning(
            "YARA rule engine failed to initialize. YARA detection is disabled."
        )

    # Check writability of log file directory
    log_dir = os.path.dirname(LOG_FILE)
    if not os.access(log_dir, os.W_OK):
        print(
            f"WARNING: Log directory '{log_dir}' is not writable. File logging might fail."
        )
        logger.warning(f"Log directory '{log_dir}' is not writable.")

    # Use environment variable for debug mode if possible, fallback to False for safety
    debug_mode = os.environ.get("FLASK_DEBUG", "0").lower() in ("true", "1", "t")
    logger.info(f"Flask debug mode: {debug_mode}")
    app.run(debug=debug_mode)
